import logging
import math
import os
import re
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Optional

import requests

from .models import Dependency, Ecosystem, Severity, Vulnerability

logger = logging.getLogger(__name__)

SESSION = requests.Session()
SESSION.headers.update({"Accept": "application/json"})
REQUEST_TIMEOUT = 12

NVD_RATE_DELAY = 0.7
_last_nvd_call = 0.0
_nvd_lock = threading.Lock()


def _parse_cvss(score_val) -> float:
    """Safely convert a CVSS score to float."""
    try:
        return float(score_val)
    except (TypeError, ValueError):
        return 0.0


def _cvss_v3_base_score(vector: str) -> float:
    """Compute CVSS v3.x base score from a vector string.

    Implements the CVSS v3.1 specification from FIRST.org.
    """
    parts = {}
    for segment in vector.split("/"):
        if ":" in segment:
            key, val = segment.split(":", 1)
            parts[key] = val

    av_map = {"N": 0.85, "A": 0.62, "L": 0.55, "P": 0.20}
    ac_map = {"L": 0.77, "H": 0.44}
    pr_unchanged = {"N": 0.85, "L": 0.62, "H": 0.27}
    pr_changed = {"N": 0.85, "L": 0.68, "H": 0.50}
    ui_map = {"N": 0.85, "R": 0.62}
    cia_map = {"H": 0.56, "L": 0.22, "N": 0.0}

    scope_changed = parts.get("S") == "C"

    av = av_map.get(parts.get("AV", ""), 0)
    ac = ac_map.get(parts.get("AC", ""), 0)
    pr_map = pr_changed if scope_changed else pr_unchanged
    pr = pr_map.get(parts.get("PR", ""), 0)
    ui = ui_map.get(parts.get("UI", ""), 0)

    c = cia_map.get(parts.get("C", ""), 0)
    i = cia_map.get(parts.get("I", ""), 0)
    a = cia_map.get(parts.get("A", ""), 0)

    if not all([av, ac, pr, ui]):
        return 0.0

    iss = 1.0 - ((1.0 - c) * (1.0 - i) * (1.0 - a))
    if iss <= 0:
        return 0.0

    exploitability = 8.22 * av * ac * pr * ui

    if scope_changed:
        impact = 7.52 * (iss - 0.029) - 3.25 * ((iss - 0.02) ** 15)
    else:
        impact = 6.42 * iss

    if impact <= 0:
        return 0.0

    if scope_changed:
        base = min(1.08 * (impact + exploitability), 10.0)
    else:
        base = min(impact + exploitability, 10.0)

    return math.ceil(base * 10) / 10


def check_osv(name: str, version: str, ecosystem: Ecosystem) -> list:
    """
    Query the OSV (Open Source Vulnerabilities) database.
    https://osv.dev/docs/
    """
    vulns = []
    eco_map = {Ecosystem.PYTHON: "PyPI", Ecosystem.NODE: "npm"}
    payload = {"package": {"name": name, "ecosystem": eco_map[ecosystem]}}
    if version:
        payload["version"] = version

    try:
        resp = SESSION.post(
            "https://api.osv.dev/v1/query",
            json=payload,
            timeout=REQUEST_TIMEOUT,
        )
        if resp.status_code != 200:
            return vulns

        data = resp.json()
        for entry in data.get("vulns", []):
            cvss = 0.0
            severity_items = entry.get("severity", [])
            for s in severity_items:
                if s.get("type") == "CVSS_V3":
                    score_str = s.get("score", "")
                    # Try direct numeric parse first
                    try:
                        cvss = float(score_str)
                    except (TypeError, ValueError):
                        # It's a CVSS vector string â€” compute score from it
                        if "CVSS:" in str(score_str):
                            cvss = _cvss_v3_base_score(str(score_str))
                    if cvss > 0:
                        break

            if cvss == 0.0:
                db_specific = entry.get("database_specific", {})
                cvss = _parse_cvss(db_specific.get("cvss_score", 0))

            affected_str = ""
            fixed_ver = None
            for affected in entry.get("affected", []):
                for rng in affected.get("ranges", []):
                    events = rng.get("events", [])
                    intro = next((e.get("introduced") for e in events if "introduced" in e), None)
                    fix = next((e.get("fixed") for e in events if "fixed" in e), None)
                    if intro and fix:
                        affected_str = f">={intro}, <{fix}"
                        fixed_ver = fix
                    elif intro:
                        affected_str = f">={intro}"

            refs = [r.get("url", "") for r in entry.get("references", []) if r.get("url")]
            cwe_list = entry.get("database_specific", {}).get("cwe_ids", [])

            vulns.append(Vulnerability(
                vuln_id=entry.get("id", ""),
                source="OSV",
                summary=(entry.get("summary") or entry.get("details", ""))[:300],
                severity=Severity.from_cvss(cvss),
                cvss_score=cvss,
                affected_versions=affected_str,
                fixed_version=fixed_ver,
                references=refs[:5],
                published=entry.get("published", ""),
                cwe_ids=cwe_list,
            ))
    except Exception as exc:
        logger.debug("OSV query failed for %s: %s", name, exc)

    return vulns


def _is_nvd_relevant(name: str, ecosystem: Ecosystem, cve: dict) -> bool:
    """Check whether an NVD CVE is actually relevant to the given package.

    Filters out false positives from the keyword-based NVD search by verifying
    the package name appears in the CVE description or in CPE match criteria.
    """
    name_lower = name.lower()

    # Check description
    for desc in cve.get("descriptions", []):
        if desc.get("lang") == "en":
            text = desc.get("value", "").lower()
            if name_lower in text:
                return True

    # Check CPE match criteria for the package name
    configs = cve.get("configurations", [])
    for config in configs:
        for node in config.get("nodes", []):
            for match in node.get("cpeMatch", []):
                cpe = match.get("criteria", "").lower()
                if name_lower in cpe:
                    return True

    return False


def check_nvd(name: str, ecosystem: Ecosystem) -> list:
    """
    Query the NVD (National Vulnerability Database) for CVEs mentioning this package.
    Respects rate limits for the public API.
    """
    global _last_nvd_call
    vulns = []

    with _nvd_lock:
        elapsed = time.time() - _last_nvd_call
        if elapsed < NVD_RATE_DELAY:
            time.sleep(NVD_RATE_DELAY - elapsed)
        _last_nvd_call = time.time()

    keyword = name
    if ecosystem == Ecosystem.NODE:
        keyword = f"npm {name}"

    try:
        resp = SESSION.get(
            "https://services.nvd.nist.gov/rest/json/cves/2.0",
            params={"keywordSearch": keyword, "resultsPerPage": 10},
            timeout=REQUEST_TIMEOUT,
        )
        if resp.status_code != 200:
            return vulns

        data = resp.json()
        for item in data.get("vulnerabilities", []):
            cve = item.get("cve", {})
            cve_id = cve.get("id", "")

            # Filter out false positives
            if not _is_nvd_relevant(name, ecosystem, cve):
                continue

            cvss = 0.0
            metrics = cve.get("metrics", {})
            for metric_key in ["cvssMetricV31", "cvssMetricV30", "cvssMetricV2"]:
                metric_list = metrics.get(metric_key, [])
                if metric_list:
                    cvss_data = metric_list[0].get("cvssData", {})
                    cvss = _parse_cvss(cvss_data.get("baseScore", 0))
                    break

            descriptions = cve.get("descriptions", [])
            summary = ""
            for desc in descriptions:
                if desc.get("lang") == "en":
                    summary = desc.get("value", "")[:300]
                    break

            cwe_list = []
            weaknesses = cve.get("weaknesses", [])
            for w in weaknesses:
                for d in w.get("description", []):
                    val = d.get("value", "")
                    if val.startswith("CWE-"):
                        cwe_list.append(val)

            refs = []
            for ref in cve.get("references", [])[:5]:
                refs.append(ref.get("url", ""))

            published = cve.get("published", "")

            vulns.append(Vulnerability(
                vuln_id=cve_id,
                source="NVD",
                summary=summary,
                severity=Severity.from_cvss(cvss),
                cvss_score=cvss,
                fixed_version=None,
                references=refs,
                published=published[:10] if published else "",
                cwe_ids=cwe_list,
            ))
    except Exception as exc:
        logger.debug("NVD query failed for %s: %s", name, exc)

    return vulns


def check_github_advisory(name: str, ecosystem: Ecosystem) -> list:
    """
    Query the GitHub Advisory Database via the public API.
    Uses the 'affects' parameter to filter server-side by package name.
    """
    vulns = []
    eco_map = {Ecosystem.PYTHON: "pip", Ecosystem.NODE: "npm"}
    eco_name = eco_map.get(ecosystem)
    if not eco_name:
        return vulns

    headers = {"Accept": "application/vnd.github+json"}
    token = os.environ.get("GITHUB_TOKEN")
    if token:
        headers["Authorization"] = f"Bearer {token}"

    try:
        resp = SESSION.get(
            "https://api.github.com/advisories",
            params={
                "affects": f"{eco_name}/{name}",
                "per_page": 30,
            },
            headers=headers,
            timeout=REQUEST_TIMEOUT,
        )
        if resp.status_code != 200:
            logger.debug(
                "GitHub Advisory API returned %d for %s", resp.status_code, name
            )
            return vulns

        data = resp.json()
        if not isinstance(data, list):
            return vulns

        for advisory in data:
            cvss = _parse_cvss(advisory.get("cvss", {}).get("score", 0))
            ghsa_id = advisory.get("ghsa_id", "")

            cwe_list = [
                c.get("cwe_id", "")
                for c in advisory.get("cwes", [])
                if c.get("cwe_id")
            ]

            published = advisory.get("published_at") or ""

            vulns.append(Vulnerability(
                vuln_id=ghsa_id or advisory.get("cve_id", ""),
                source="GitHub Advisory",
                summary=(advisory.get("summary") or "")[:300],
                severity=Severity.from_cvss(cvss),
                cvss_score=cvss,
                references=[advisory.get("html_url", "")],
                published=published[:10],
                cwe_ids=cwe_list,
            ))
    except Exception as exc:
        logger.debug("GitHub Advisory query failed for %s: %s", name, exc)

    return vulns


def _deduplicate(vulns: list) -> list:
    """Remove duplicate entries based on vuln_id."""
    seen = set()
    unique = []
    for v in vulns:
        if v.vuln_id and v.vuln_id not in seen:
            seen.add(v.vuln_id)
            unique.append(v)
        elif not v.vuln_id:
            unique.append(v)
    return unique


def check_package(dep: Dependency) -> list:
    """
    Run a package against all vulnerability sources and return a
    deduplicated, sorted list of findings.
    """
    all_vulns = []

    osv_results = check_osv(dep.name, dep.version, dep.ecosystem)
    all_vulns.extend(osv_results)

    nvd_results = check_nvd(dep.name, dep.ecosystem)
    all_vulns.extend(nvd_results)

    ghsa_results = check_github_advisory(dep.name, dep.ecosystem)
    all_vulns.extend(ghsa_results)

    deduped = _deduplicate(all_vulns)

    severity_order = {
        Severity.CRITICAL: 0,
        Severity.HIGH: 1,
        Severity.MEDIUM: 2,
        Severity.LOW: 3,
        Severity.NONE: 4,
    }
    deduped.sort(key=lambda v: (severity_order.get(v.severity, 4), -v.cvss_score))
    return deduped


def _vuln_map_key(dep: Dependency) -> str:
    """Create a unique key for the vulnerability results map.

    Uses ecosystem:name to avoid collisions when Python and Node packages
    share the same name.
    """
    return f"{dep.ecosystem.value}:{dep.name}"


def check_all_packages(
    dependencies: list, max_workers: int = 6, progress_callback=None
) -> dict:
    """
    Check vulnerabilities for a list of Dependency objects in parallel.
    Returns a mapping of 'ecosystem:package_name' -> list of Vulnerability.
    """
    results = {}
    completed = 0
    total = len(dependencies)

    with ThreadPoolExecutor(max_workers=max_workers) as pool:
        futures = {pool.submit(check_package, dep): dep for dep in dependencies}
        for future in as_completed(futures):
            dep = futures[future]
            completed += 1
            key = _vuln_map_key(dep)
            try:
                vulns = future.result()
                results[key] = vulns
            except Exception as exc:
                logger.warning("Vulnerability check failed for %s: %s", dep.name, exc)
                results[key] = []

            if progress_callback:
                progress_callback(completed, total, dep.name)

    return results
